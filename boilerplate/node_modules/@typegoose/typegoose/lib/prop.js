"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const mongoose = require("mongoose");
const util_1 = require("util");
const constants_1 = require("./internal/constants");
const data_1 = require("./internal/data");
const errors_1 = require("./internal/errors");
const utils = require("./internal/utils");
const logSettings_1 = require("./logSettings");
const typegoose_1 = require("./typegoose");
/** This Enum is meant for baseProp to decide for diffrent props (like if it is an arrayProp or prop or mapProp) */
var WhatIsIt;
(function (WhatIsIt) {
    WhatIsIt[WhatIsIt["ARRAY"] = 0] = "ARRAY";
    WhatIsIt[WhatIsIt["MAP"] = 1] = "MAP";
    WhatIsIt[WhatIsIt["NONE"] = 2] = "NONE";
})(WhatIsIt || (WhatIsIt = {}));
/**
 * Base Function for prop & arrayProp
 * @param origOptions The options (like require)
 * @param Type What Type it is
 * @param target Target Class
 * @param key Value Key of target class
 * @param isArray is it an array?
 */
function baseProp(origOptions, Type, target, key, whatis = WhatIsIt.NONE) {
    if (Type === target) {
        throw new Error('It seems like the type used is the same as the target class, which is currently not supported\n'
            + `Please look at https://github.com/typegoose/typegoose/issues/42 for more infomation, for now please avoid using it!`);
    }
    const initname = utils.createUniqueID(target);
    data_1.decoratorCache.get(initname).decorators.set(key, () => {
        const rawOptions = Object.assign({}, origOptions);
        if (utils.isNotDefined(Type)) {
            if (Type !== target) { // prevent "infinite" buildSchema loop / Maximum Class size exceeded
                typegoose_1.buildSchema(Type, { _id: typeof rawOptions._id === 'boolean' ? rawOptions._id : true });
            }
        }
        const name = utils.getName(target.constructor);
        if (!data_1.virtuals.get(name)) {
            data_1.virtuals.set(name, new Map());
        }
        if (utils.isWithVirtualPOP(rawOptions)) {
            if (!utils.includesAllVirtualPOP(rawOptions)) {
                throw new errors_1.NotAllVPOPElementsError(name, key);
            }
            data_1.virtuals.get(name).set(key, rawOptions);
            return;
        }
        if (whatis === WhatIsIt.ARRAY) {
            utils.initAsArray(name, key);
        }
        else {
            utils.initAsObject(name, key);
        }
        if (!util_1.isNullOrUndefined(rawOptions.set) || !util_1.isNullOrUndefined(rawOptions.get)) {
            if (typeof rawOptions.set !== 'function') {
                throw new TypeError(`"${name}.${key}" does not have a set function!`);
            }
            if (typeof rawOptions.get !== 'function') {
                throw new TypeError(`"${name}.${key}" does not have a get function!`);
            }
            const newType = rawOptions && rawOptions.type ? rawOptions.type : Type;
            if (rawOptions && rawOptions.type) {
                delete rawOptions.type;
            }
            /*
             * Note:
             * this dosnt have a check if prop & returntype of the function is the same,
             * because it cant be accessed at runtime
             */
            data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: newType }), rawOptions);
            return;
        }
        const ref = rawOptions.ref;
        const refType = rawOptions.refType || mongoose.Schema.Types.ObjectId;
        if (ref) {
            if (whatis === WhatIsIt.ARRAY) {
                logSettings_1.logger.warn('"ref" is used in an arrayProp, which should not be used! (%s, %s)\n'
                    + 'Use "itemsRef"', utils.getName(target), key);
            }
            delete rawOptions.ref;
            const refName = typeof ref === 'string' ? ref : utils.getName(ref);
            data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: refType, ref: refName }), rawOptions);
            return;
        }
        const itemsRef = rawOptions.itemsRef;
        const itemsRefType = rawOptions.itemsRefType || mongoose.Schema.Types.ObjectId;
        if (itemsRef) {
            const itemsRefName = typeof itemsRef === 'string' ? itemsRef : utils.getName(itemsRef);
            delete rawOptions.itemsRef;
            data_1.schemas.get(name)[key][0] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), { type: itemsRefType, ref: itemsRefName }), rawOptions);
            return;
        }
        const refPath = rawOptions.refPath;
        if (refPath && typeof refPath === 'string') {
            if (whatis === WhatIsIt.ARRAY) {
                logSettings_1.logger.warn('"refPath" is used in an arrayProp, which should not be used! (%s, %s)\n'
                    + 'Use "itemsRefPath"', utils.getName(target), key);
            }
            delete rawOptions.refPath;
            data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: refType, refPath }), rawOptions);
            return;
        }
        const itemsRefPath = rawOptions.itemsRefPath;
        if (itemsRefPath && typeof itemsRefPath === 'string') {
            delete rawOptions.itemsRefPath;
            data_1.schemas.get(name)[key][0] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), { type: itemsRefType, refPath: itemsRefPath }), rawOptions);
            return;
        }
        const enumOption = rawOptions.enum;
        if (enumOption) {
            if (!Array.isArray(enumOption)) {
                rawOptions.enum = Object.keys(enumOption).map((propKey) => enumOption[propKey]);
            }
        }
        const selectOption = rawOptions.select;
        if (typeof selectOption === 'boolean') {
            data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { select: selectOption });
        }
        // check if Type is actually a real working Type
        if (util_1.isNullOrUndefined(Type) || typeof Type !== 'function') {
            throw new errors_1.InvalidTypeError(target.constructor.name, key, Type);
        }
        // check for validation inconsistencies
        if (utils.isWithStringValidate(rawOptions) && !utils.isString(Type)) {
            throw new errors_1.NotStringTypeError(key);
        }
        // check for transform inconsistencies
        if (utils.isWithStringTransform(rawOptions) && !utils.isString(Type)) {
            throw new errors_1.NotStringTypeError(key);
        }
        if (utils.isWithNumberValidate(rawOptions) && !utils.isNumber(Type)) {
            throw new errors_1.NotNumberTypeError(key);
        }
        const subSchema = data_1.schemas.get(utils.getName(Type));
        if (!subSchema && !utils.isPrimitive(Type) && !utils.isObject(Type)) {
            throw new errors_1.InvalidPropError(Type.name, key); // This seems to be never thrown!
        }
        const { ['items']: items } = rawOptions, options = __rest(rawOptions, ['items']);
        if (utils.isPrimitive(Type)) {
            switch (whatis) {
                case WhatIsIt.ARRAY:
                    data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), options), { type: [Type] });
                    return;
                case WhatIsIt.MAP:
                    // "default" is a reserved keyword, thats why "_default" is used
                    const { default: _default } = options;
                    delete options.default;
                    delete options.of;
                    data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: Map, default: _default, of: Object.assign({ type: Type }, options) });
                    return;
                case WhatIsIt.NONE:
                    data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), options), { type: Type });
                    return;
                default:
                    throw new Error(`"${whatis}"(whatis(primitive)) is invalid for "${name}.${key}"`);
            }
        }
        // If the 'Type' is not a 'Primitive Type' and no subschema was found treat the type as 'Object'
        // so that mongoose can store it as nested document
        if (utils.isObject(Type) && !subSchema) {
            data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), options), { type: Object // i think this could take some improvements
             });
            return;
        }
        switch (whatis) {
            case WhatIsIt.ARRAY:
                const virtualSchemaArrayItem = typegoose_1.buildSchema(Type, {
                    _id: typeof rawOptions._id === 'boolean' ? rawOptions._id : true
                });
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), options), { type: [virtualSchemaArrayItem] });
                return;
            case WhatIsIt.MAP:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: Map }), options);
                data_1.schemas.get(name)[key].of = Object.assign(Object.assign({}, data_1.schemas.get(name)[key].of), subSchema);
                return;
            case WhatIsIt.NONE:
                const virtualSchema = typegoose_1.buildSchema(Type, {
                    _id: typeof rawOptions._id === 'boolean' ? rawOptions._id : true
                });
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), options), { type: virtualSchema });
                return;
            default:
                throw new Error(`"${whatis}"(whatis(subSchema)) is invalid for "${name}.${key}"`);
        }
    });
}
/**
 * Set Property Options for the property below
 * @param options Options
 * @public
 */
function prop(options = {}) {
    return (target, key) => {
        const Type = Reflect.getMetadata(constants_1.DecoratorKeys.Prop, target, key);
        if (!Type) {
            throw new errors_1.NoMetadataError(key);
        }
        // soft errors
        {
            if ('items' in options) {
                logSettings_1.logger.warn(new Error('You might not want to use option "items" in a @prop'));
            }
            if ('of' in options) {
                logSettings_1.logger.warn(new Error('You might not want to use option "of" in a @prop'));
            }
        }
        baseProp(options, Type, target, key, WhatIsIt.NONE);
    };
}
exports.prop = prop;
/**
 * Set Property(that are Maps) Options for the property below
 * @param options Options for the Map
 * @public
 */
function mapProp(options) {
    return (target, key) => {
        const Type = options.of;
        if ('items' in options) {
            logSettings_1.logger.warn(new Error('You might not want to use option "items" in a @mapProp'));
        }
        baseProp(options, Type, target, key, WhatIsIt.MAP);
    };
}
exports.mapProp = mapProp;
/**
 * Set Property(that are Arrays) Options for the property below
 * @param options Options
 * @public
 */
function arrayProp(options) {
    return (target, key) => {
        const Type = options.items;
        if ('of' in options) {
            logSettings_1.logger.warn(new Error('You might not want to use option "of" in a @arrayProp'));
        }
        baseProp(options, Type, target, key, WhatIsIt.ARRAY);
    };
}
exports.arrayProp = arrayProp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQ0FBcUM7QUFFckMsK0JBQXlDO0FBQ3pDLG9EQUFxRDtBQUNyRCwwQ0FBb0U7QUFDcEUsOENBTzJCO0FBRTNCLDBDQUEwQztBQUMxQywrQ0FBdUM7QUFDdkMsMkNBQTBDO0FBUzFDLG1IQUFtSDtBQUNuSCxJQUFLLFFBSUo7QUFKRCxXQUFLLFFBQVE7SUFDWCx5Q0FBSyxDQUFBO0lBQ0wscUNBQUcsQ0FBQTtJQUNILHVDQUFJLENBQUE7QUFDTixDQUFDLEVBSkksUUFBUSxLQUFSLFFBQVEsUUFJWjtBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFTLFFBQVEsQ0FDZixXQUFnQixFQUNoQixJQUE4QixFQUM5QixNQUFXLEVBQ1gsR0FBVyxFQUNYLFNBQW1CLFFBQVEsQ0FBQyxJQUFJO0lBRWhDLElBQUksSUFBSSxLQUFLLE1BQU0sRUFBRTtRQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLGlHQUFpRztjQUM3RyxxSEFBcUgsQ0FBQyxDQUFDO0tBQzVIO0lBRUQsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUU5QyxxQkFBYyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7UUFDcEQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFFbEQsSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzVCLElBQUksSUFBSSxLQUFLLE1BQU0sRUFBRSxFQUFFLG9FQUFvRTtnQkFDekYsdUJBQVcsQ0FBQyxJQUFJLEVBQUUsRUFBRSxHQUFHLEVBQUUsT0FBTyxVQUFVLENBQUMsR0FBRyxLQUFLLFNBQVMs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