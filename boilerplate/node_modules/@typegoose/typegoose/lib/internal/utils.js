"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mongoose = require("mongoose");
const util_1 = require("util");
const constants_1 = require("./constants");
const data_1 = require("./data");
const errors_1 = require("./errors");
const primitives = ['String', 'Number', 'Boolean', 'Date', 'Decimal128', 'ObjectID', 'Array'];
/**
 * Returns true, if it includes the Type
 * @param Type The Type
 * @returns true, if it includes it
 */
function isPrimitive(Type) {
    return primitives.includes(Type.name);
}
exports.isPrimitive = isPrimitive;
/**
 * Returns true, if it is an Object
 * @param Type The Type
 * @returns true, if it is an Object
 */
function isObject(Type) {
    let prototype = Type.prototype;
    let name = Type.name;
    while (name) {
        if (name === 'Object') {
            return true;
        }
        prototype = Object.getPrototypeOf(prototype);
        name = prototype ? prototype.constructor.name : null;
    }
    return false; // can this even return false?
    // return !isNullOrUndefined(Type) && (typeof Type === 'object' || Type.name === 'Object') && !Array.isArray(Type);
}
exports.isObject = isObject;
/**
 * Returns true, if it is an Number
 * @param Type The Type
 * @returns true, if it is an Number
 */
function isNumber(Type) {
    return Type.name === 'Number';
}
exports.isNumber = isNumber;
/**
 * Returns true, if it is an String
 * @param Type The Type
 * @returns true, if it is an String
 */
function isString(Type) {
    return Type.name === 'String';
}
exports.isString = isString;
/**
 * Initialize as Object
 * @param name The Name of the Schema
 * @param key The Property key to set
 */
function initAsObject(name, key) {
    if (!data_1.schemas.get(name)) {
        data_1.schemas.set(name, {});
    }
    data_1.schemas.get(name)[key] = {};
}
exports.initAsObject = initAsObject;
/**
 * Initialize as Array
 * @param name The Name of the Schema
 * @param key The Property key to set
 */
function initAsArray(name, key) {
    if (!data_1.schemas.get(name)) {
        data_1.schemas.set(name, {});
    }
    data_1.schemas.get(name)[key] = [{}];
}
exports.initAsArray = initAsArray;
/**
 * Get the Class for a given Document
 * @param document The Document
 */
function getClassForDocument(document) {
    const modelName = document.constructor.modelName;
    return data_1.constructors.get(modelName);
}
exports.getClassForDocument = getClassForDocument;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithStringValidate(options) {
    return !util_1.isNullOrUndefined(options.match
        || options.enum
        || options.minlength
        || options.maxlength);
}
exports.isWithStringValidate = isWithStringValidate;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithStringTransform(options) {
    return !util_1.isNullOrUndefined(options.lowercase || options.uppercase || options.trim);
}
exports.isWithStringTransform = isWithStringTransform;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithNumberValidate(options) {
    return !util_1.isNullOrUndefined(options.min || options.max);
}
exports.isWithNumberValidate = isWithNumberValidate;
const virtualOptions = ['localField', 'foreignField'];
/**
 * Check if Options include Virtual Populate Options
 * @param options RawOptions of the Prop
 */
function isWithVirtualPOP(options) {
    return Object.keys(options).some((v) => virtualOptions.includes(v));
}
exports.isWithVirtualPOP = isWithVirtualPOP;
exports.allVirtualoptions = virtualOptions.slice(0);
exports.allVirtualoptions.push('ref');
/**
 * Check if All the required Options are present
 * @param options RawOptions of the Prop
 */
function includesAllVirtualPOP(options) {
    return exports.allVirtualoptions.every((v) => Object.keys(options).includes(v));
}
exports.includesAllVirtualPOP = includesAllVirtualPOP;
/**
 * Check if the given value has options of "IModelOptions"
 * @param value The Value to evaulate
 * @internal
 */
function isModelOptions(value) {
    return value && (typeof value.schemaOptions === 'object' ||
        typeof value.options === 'object');
}
/**
 * Merge value & existing Metadata & Save it to the class
 * Difference with "mergeMetadata" is that this one DOES save it to the class
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
function assignMetadata(key, value, cl) {
    if (util_1.isNullOrUndefined(value)) {
        return value;
    }
    const newValue = mergeMetadata(key, value, cl);
    Reflect.defineMetadata(key, newValue, cl);
    return newValue;
}
exports.assignMetadata = assignMetadata;
/**
 * Merge value & existing Metadata
 * Difference with "assignMetadata" is that this one DOES NOT save it to the class
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
function mergeMetadata(key, value, cl) {
    if (typeof key !== 'string') {
        throw new TypeError(`"${key}"(key) is not a string! (assignMetadata)`);
    }
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    const current = Object.assign({}, Reflect.getMetadata(key, cl) || {});
    if (util_1.isNullOrUndefined(value)) {
        return current;
    }
    // the following checks are needed, so that the new value dosnt override the full options
    // "deepmerge" cannot be used because of the other options like "existingMongoose"
    if (isModelOptions(value) && !util_1.isNullOrUndefined(current.schemaOptions)) {
        value.schemaOptions = Object.assign(current.schemaOptions, value.schemaOptions);
    }
    if (isModelOptions(value) && !util_1.isNullOrUndefined(current.options)) {
        value.options = Object.assign(current.options, value.options);
    }
    return Object.assign(current, value);
}
exports.mergeMetadata = mergeMetadata;
/**
 * Merge only schemaOptions from ModelOptions of the class
 * @param value The value to use
 * @param cl The Class to get the values from
 */
function mergeSchemaOptions(value, cl) {
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    const current = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, cl) || {};
    const evaluated = current && current.schemaOptions ? current.schemaOptions : {};
    if (util_1.isNullOrUndefined(value)) {
        return evaluated;
    }
    return Object.assign(evaluated, value || {});
}
exports.mergeSchemaOptions = mergeSchemaOptions;
/**
 * Get the correct name of the class's model
 * (with suffix)
 * @param cl The Class
 */
function getName(cl) {
    const options = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, cl) || {};
    const baseName = cl.name;
    if (options.options && options.options.automaticName) {
        const suffix = (options.options ? options.options.customName : undefined) ||
            (options.schemaOptions ? options.schemaOptions.collection : undefined);
        return suffix ? `${baseName}_${suffix}` : baseName;
    }
    if (options.options && typeof options.options.customName === 'string') {
        if (options.options.customName.length <= 0) {
            throw new TypeError(`"customName" must be a string AND at least one character ("${cl.name}")`);
        }
        return options.options.customName;
    }
    return baseName;
}
exports.getName = getName;
/**
 * Returns if it is not defined in "schemas"
 * @param cl The Type
 */
function isNotDefined(cl) {
    return typeof cl === 'function' &&
        !isPrimitive(cl) &&
        cl !== Object &&
        cl !== mongoose.Schema.Types.Buffer &&
        util_1.isNullOrUndefined(data_1.schemas.get(getName(cl)));
}
exports.isNotDefined = isNotDefined;
/**
 * Assign "__uniqueID" to a class
 * (used for the decoratorCache)
 * @param cl
 * @returns the initname to be used as identifier
 */
function createUniqueID(cl) {
    if (util_1.isNullOrUndefined(cl.__uniqueID)) {
        cl.__uniqueID = Date.now();
    }
    const initname = `${cl.constructor.name}_${cl.__uniqueID}`;
    if (!data_1.decoratorCache.get(initname)) {
        data_1.decoratorCache.set(initname, { class: cl.constructor, decorators: new Map() });
    }
    return initname;
}
exports.createUniqueID = createUniqueID;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW50ZXJuYWwvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBcUM7QUFFckMsK0JBQXlDO0FBUXpDLDJDQUE0QztBQUM1QyxpQ0FBK0Q7QUFDL0QscUNBQXdDO0FBRXhDLE1BQU0sVUFBVSxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFFOUY7Ozs7R0FJRztBQUNILFNBQWdCLFdBQVcsQ0FBQyxJQUFTO0lBQ25DLE9BQU8sVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUZELGtDQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFFBQVEsQ0FBQyxJQUFTO0lBQ2hDLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDL0IsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNyQixPQUFPLElBQUksRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNyQixPQUFPLElBQUksQ0FBQztTQUNiO1FBQ0QsU0FBUyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDN0MsSUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUN0RDtJQUVELE9BQU8sS0FBSyxDQUFDLENBQUMsOEJBQThCO0lBQzVDLG1IQUFtSDtBQUNySCxDQUFDO0FBYkQsNEJBYUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsUUFBUSxDQUFDLElBQVM7SUFDaEMsT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztBQUNoQyxDQUFDO0FBRkQs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