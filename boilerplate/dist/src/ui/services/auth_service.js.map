{"version":3,"file":"auth_service.js","sourceRoot":"","sources":["../../../../src/ui/services/auth_service.ts"],"names":[],"mappings":"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","sourcesContent":["import bcrypt from \"bcrypt\";\nimport { plainToClass } from \"class-transformer\";\nimport { EventDispatcher } from \"event-dispatch\";\nimport httpStatus from \"http-status-codes\";\nimport jwt from \"jsonwebtoken\";\nimport { eventDispatcher } from \"../../core/domain/constants/decorators\";\nimport { IUserRepository, Query } from \"../../core/domain/data/repositories\";\nimport {\n    PASSWORD_SALT_ROUND,\n    User,\n    UserRole\n} from \"../../core/domain/models/user\";\nimport { config } from \"../../infrastructure/config\";\nimport { inject, provideSingleton } from \"../../infrastructure/config/ioc\";\nimport { UserRepository } from \"../../infrastructure/db/repositories/user_repository\";\nimport { HttpError } from \"../error\";\nimport { IAuthService } from \"../../core/domain/services/auth_service\";\nimport { UserDto, UserSignInInput, UserSignUpInput } from \"../models/user_dto\";\nimport { events } from \"../subscribers/events\";\nimport { and, or, lt } from \"../../core/domain/data/db_operators\";\n\nexport interface DecodedJwt {\n    userId: string;\n    role: UserRole;\n    email: string;\n    username: string;\n    firstName: string;\n    tenantId: any;\n}\n@provideSingleton(AuthService)\nexport class AuthService implements IAuthService {\n    @inject(UserRepository) private _userRepository: IUserRepository;\n    @eventDispatcher private _eventDispatcher: EventDispatcher;\n\n    public async signUp(\n        dto: UserSignUpInput\n    ): Promise<{ userDto: UserDto; token: string }> {\n        // Use less salt round for faster hashing on test and development but stronger hashing on production\n        const saltRound =\n            config.env === \"development\" || config.env === \"test\"\n                ? 1\n                : PASSWORD_SALT_ROUND;\n        const hashedPassword = await bcrypt.hash(dto.password, saltRound);\n\n        let user = await this._userRepository.findOneByQuery({\n            email: dto.email\n        });\n        if (user)\n            throw new HttpError(\n                httpStatus.CONFLICT,\n                `Email \"${dto.email.toLowerCase()}\" is already taken`\n            );\n        user = await this._userRepository.findOneByQuery({\n            username: dto.username\n        });\n\n        if (user)\n            throw new HttpError(\n                httpStatus.CONFLICT,\n                `Username \"${dto.username.toLowerCase()}\" is already taken`\n            );\n        user = await this._userRepository.insertOrUpdate(\n            User.createInstance({\n                ...dto,\n                password: hashedPassword\n            })\n        );\n\n        this._eventDispatcher.dispatch(events.user.signUp, { ...dto });\n\n        const token = await this.generateToken(user);\n        const userDto = plainToClass(UserDto, user, {\n            enableImplicitConversion: true,\n            excludeExtraneousValues: true\n        });\n        return { userDto, token };\n    }\n\n    public async signIn(dto: UserSignInInput): Promise<{ token: string }> {\n        const user = await this.getUserRecord(dto.emailOrUsername);\n\n        await this.processSignInAttempt(dto, user);\n\n        const token = await this.generateToken(user);\n        return { token };\n    }\n\n    private async processSignInAttempt(dto: UserSignInInput, user: User) {\n        if (!user)\n            throw new HttpError(\n                httpStatus.UNAUTHORIZED,\n                \"Invalid login attempt!\"\n            );\n\n        const isPasswordValid = await bcrypt.compare(\n            dto.password,\n            user.password\n        );\n        if (user.isLockedOut || !isPasswordValid) {\n            throw new HttpError(\n                httpStatus.BAD_REQUEST,\n                \"Invalid login attempt!\"\n            );\n        }\n\n        // clear the signin attempts of the user and lockout end date\n        user.clearLockOut();\n        await this._userRepository.insertOrUpdate(user);\n    }\n\n    private async getUserRecord(emailOrUsername: string): Promise<User> {\n        // increase the user's signin attempt for every of this call if the user is not yet locked\n        return this._userRepository.findOneByQueryAndUpdate(\n            this.getSignInQuery(emailOrUsername),\n            User.getSignInAttemptUpdate()\n        );\n    }\n\n    private getSignInQuery(\n        emailOrUsername: string\n    ): Query<{ [key: string]: object }> {\n        return and(\n            or({ email: emailOrUsername }, { username: emailOrUsername }),\n            or(\n                {\n                    failedSignInAttempts: lt(\n                        config.userLockout.maxSignInAttempts\n                    )\n                },\n                {\n                    lockOutEndDate: lt(new Date())\n                }\n            )\n        );\n    }\n\n    private async generateToken(user: User) {\n        const today = new Date();\n        const exp = new Date(today);\n        exp.setDate(today.getDate() + 60);\n\n        const payload: DecodedJwt = {\n            userId: user.id,\n            role: user.role,\n            email: user.email,\n            username: user.username,\n            firstName: user.firstName,\n            tenantId: user.tenant\n        };\n        return jwt.sign(payload, config.jwtSecret, { expiresIn: \"2 days\" });\n    }\n}\n"]}